{"ast":null,"code":"import _classCallCheck from \"/Users/apple/Desktop/LMGame/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/apple/Desktop/LMGame/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _defineProperty from \"/Users/apple/Desktop/LMGame/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _slicedToArray from \"/Users/apple/Desktop/LMGame/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/Users/apple/Desktop/LMGame/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, Optional, NgModule } from '@angular/core';\nimport { asyncScheduler, Observable, of, merge } from 'rxjs';\nimport { map, share, switchMap, scan, distinctUntilChanged, withLatestFrom, skipWhile } from 'rxjs/operators';\nimport * as i1 from '@angular/fire';\nimport { keepUnstableUntilFirst, VERSION } from '@angular/fire';\nimport { ɵfirebaseAppFactory, ɵcacheInstance, FIREBASE_OPTIONS, FIREBASE_APP_NAME } from '@angular/fire/compat';\nimport 'firebase/compat/auth';\nimport 'firebase/compat/database';\nimport * as i2 from '@angular/fire/compat/auth';\nimport { ɵauthFactory, USE_EMULATOR as USE_EMULATOR$1, SETTINGS, TENANT_ID, LANGUAGE_CODE, USE_DEVICE_LANGUAGE, PERSISTENCE } from '@angular/fire/compat/auth';\nimport * as i3 from '@angular/fire/app-check';\nimport firebase from 'firebase/compat/app';\n\nfunction isString(value) {\n  return typeof value === 'string';\n}\n\nfunction isFirebaseDataSnapshot(value) {\n  return typeof value.exportVal === 'function';\n}\n\nfunction isNil(obj) {\n  return obj === undefined || obj === null;\n}\n\nfunction isFirebaseRef(value) {\n  return typeof value.set === 'function';\n}\n/**\n * Returns a database reference given a Firebase App and an\n * absolute or relative path.\n * @param database - Firebase Database\n * @param pathRef - Database path, relative or absolute\n */\n\n\nfunction getRef(database, pathRef) {\n  // if a db ref was passed in, just return it\n  return isFirebaseRef(pathRef) ? pathRef : database.ref(pathRef);\n}\n\nfunction checkOperationCases(item, cases) {\n  if (isString(item)) {\n    return cases.stringCase();\n  } else if (isFirebaseRef(item)) {\n    return cases.firebaseCase();\n  } else if (isFirebaseDataSnapshot(item)) {\n    return cases.snapshotCase();\n  }\n\n  throw new Error(\"Expects a string, snapshot, or reference. Got: \".concat(typeof item));\n}\n/**\n * Create an observable from a Database Reference or Database Query.\n * @param ref Database Reference\n * @param event Listen event type ('value', 'added', 'changed', 'removed', 'moved')\n * @param listenType 'on' or 'once'\n * @param scheduler - Rxjs scheduler\n */\n\n\nfunction fromRef(ref, event) {\n  var listenType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'on';\n  var scheduler = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : asyncScheduler;\n  return new Observable(function (subscriber) {\n    var fn = null;\n    fn = ref[listenType](event, function (snapshot, prevKey) {\n      scheduler.schedule(function () {\n        subscriber.next({\n          snapshot: snapshot,\n          prevKey: prevKey\n        });\n      });\n\n      if (listenType === 'once') {\n        scheduler.schedule(function () {\n          return subscriber.complete();\n        });\n      }\n    }, function (err) {\n      scheduler.schedule(function () {\n        return subscriber.error(err);\n      });\n    });\n\n    if (listenType === 'on') {\n      return {\n        unsubscribe: function unsubscribe() {\n          if (fn != null) {\n            ref.off(event, fn);\n          }\n        }\n      };\n    } else {\n      return {\n        unsubscribe: function unsubscribe() {}\n      };\n    }\n  }).pipe(map(function (payload) {\n    var snapshot = payload.snapshot,\n        prevKey = payload.prevKey;\n    var key = null;\n\n    if (snapshot.exists()) {\n      key = snapshot.key;\n    }\n\n    return {\n      type: event,\n      payload: snapshot,\n      prevKey: prevKey,\n      key: key\n    };\n  }), share());\n}\n\nfunction listChanges(ref, events, scheduler) {\n  return fromRef(ref, 'value', 'once', scheduler).pipe(switchMap(function (snapshotAction) {\n    var childEvent$ = [of(snapshotAction)];\n    events.forEach(function (event) {\n      return childEvent$.push(fromRef(ref, event, 'on', scheduler));\n    });\n    return merge.apply(void 0, childEvent$).pipe(scan(buildView, []));\n  }), distinctUntilChanged());\n}\n\nfunction positionFor(changes, key) {\n  var len = changes.length;\n\n  for (var i = 0; i < len; i++) {\n    if (changes[i].payload.key === key) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction positionAfter(changes, prevKey) {\n  if (isNil(prevKey)) {\n    return 0;\n  } else {\n    var i = positionFor(changes, prevKey);\n\n    if (i === -1) {\n      return changes.length;\n    } else {\n      return i + 1;\n    }\n  }\n}\n\nfunction buildView(current, action) {\n  var payload = action.payload,\n      prevKey = action.prevKey,\n      key = action.key;\n  var currentKeyPosition = positionFor(current, key);\n  var afterPreviousKeyPosition = positionAfter(current, prevKey);\n\n  switch (action.type) {\n    case 'value':\n      if (action.payload && action.payload.exists()) {\n        var _prevKey = null;\n        action.payload.forEach(function (payload) {\n          var action = {\n            payload: payload,\n            type: 'value',\n            prevKey: _prevKey,\n            key: payload.key\n          };\n          _prevKey = payload.key;\n          current = [].concat(_toConsumableArray(current), [action]);\n          return false;\n        });\n      }\n\n      return current;\n\n    case 'child_added':\n      if (currentKeyPosition > -1) {\n        // check that the previouskey is what we expect, else reorder\n        var previous = current[currentKeyPosition - 1];\n\n        if ((previous && previous.key || null) !== prevKey) {\n          current = current.filter(function (x) {\n            return x.payload.key !== payload.key;\n          });\n          current.splice(afterPreviousKeyPosition, 0, action);\n        }\n      } else if (prevKey == null) {\n        return [action].concat(_toConsumableArray(current));\n      } else {\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, action);\n      }\n\n      return current;\n\n    case 'child_removed':\n      return current.filter(function (x) {\n        return x.payload.key !== payload.key;\n      });\n\n    case 'child_changed':\n      return current.map(function (x) {\n        return x.payload.key === key ? action : x;\n      });\n\n    case 'child_moved':\n      if (currentKeyPosition > -1) {\n        var data = current.splice(currentKeyPosition, 1)[0];\n        current = current.slice();\n        current.splice(afterPreviousKeyPosition, 0, data);\n        return current;\n      }\n\n      return current;\n    // default will also remove null results\n\n    default:\n      return current;\n  }\n}\n\nfunction validateEventsArray(events) {\n  if (isNil(events) || events.length === 0) {\n    events = ['child_added', 'child_removed', 'child_changed', 'child_moved'];\n  }\n\n  return events;\n}\n\nfunction _snapshotChanges(query, events, scheduler) {\n  events = validateEventsArray(events);\n  return listChanges(query, events, scheduler);\n}\n\nfunction _stateChanges(query, events, scheduler) {\n  events = validateEventsArray(events);\n  var childEvent$ = events.map(function (event) {\n    return fromRef(query, event, 'on', scheduler);\n  });\n  return merge.apply(void 0, _toConsumableArray(childEvent$));\n}\n\nfunction _auditTrail(query, events, scheduler) {\n  var auditTrail$ = _stateChanges(query, events).pipe(scan(function (current, action) {\n    return [].concat(_toConsumableArray(current), [action]);\n  }, []));\n\n  return waitForLoaded(query, auditTrail$, scheduler);\n}\n\nfunction loadedData(query, scheduler) {\n  // Create an observable of loaded values to retrieve the\n  // known dataset. This will allow us to know what key to\n  // emit the \"whole\" array at when listening for child events.\n  return fromRef(query, 'value', 'on', scheduler).pipe(map(function (data) {\n    // Store the last key in the data set\n    var lastKeyToLoad; // Loop through loaded dataset to find the last key\n\n    data.payload.forEach(function (child) {\n      lastKeyToLoad = child.key;\n      return false;\n    }); // return data set and the current last key loaded\n\n    return {\n      data: data,\n      lastKeyToLoad: lastKeyToLoad\n    };\n  }));\n}\n\nfunction waitForLoaded(query, action$, scheduler) {\n  var loaded$ = loadedData(query, scheduler);\n  return loaded$.pipe(withLatestFrom(action$), // Get the latest values from the \"loaded\" and \"child\" datasets\n  // We can use both datasets to form an array of the latest values.\n  map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        loaded = _ref2[0],\n        actions = _ref2[1];\n\n    // Store the last key in the data set\n    var lastKeyToLoad = loaded.lastKeyToLoad; // Store all child keys loaded at this point\n\n    var loadedKeys = actions.map(function (snap) {\n      return snap.key;\n    });\n    return {\n      actions: actions,\n      lastKeyToLoad: lastKeyToLoad,\n      loadedKeys: loadedKeys\n    };\n  }), // This is the magical part, only emit when the last load key\n  // in the dataset has been loaded by a child event. At this point\n  // we can assume the dataset is \"whole\".\n  skipWhile(function (meta) {\n    return meta.loadedKeys.indexOf(meta.lastKeyToLoad) === -1;\n  }), // Pluck off the meta data because the user only cares\n  // to iterate through the snapshots\n  map(function (meta) {\n    return meta.actions;\n  }));\n}\n\nfunction createDataOperationMethod(ref, operation) {\n  return function dataOperation(item, value) {\n    return checkOperationCases(item, {\n      stringCase: function stringCase() {\n        return ref.child(item)[operation](value);\n      },\n      firebaseCase: function firebaseCase() {\n        return item[operation](value);\n      },\n      snapshotCase: function snapshotCase() {\n        return item.ref[operation](value);\n      }\n    });\n  };\n} // TODO(davideast): Find out why TS thinks this returns firebase.Primise\n// instead of Promise.\n\n\nfunction createRemoveMethod(ref) {\n  return function remove(item) {\n    if (!item) {\n      return ref.remove();\n    }\n\n    return checkOperationCases(item, {\n      stringCase: function stringCase() {\n        return ref.child(item).remove();\n      },\n      firebaseCase: function firebaseCase() {\n        return item.remove();\n      },\n      snapshotCase: function snapshotCase() {\n        return item.ref.remove();\n      }\n    });\n  };\n}\n\nfunction createListReference(query, afDatabase) {\n  var outsideAngularScheduler = afDatabase.schedulers.outsideAngular;\n  var refInZone = afDatabase.schedulers.ngZone.run(function () {\n    return query.ref;\n  });\n  return {\n    query: query,\n    update: createDataOperationMethod(refInZone, 'update'),\n    set: createDataOperationMethod(refInZone, 'set'),\n    push: function push(data) {\n      return refInZone.push(data);\n    },\n    remove: createRemoveMethod(refInZone),\n    snapshotChanges: function snapshotChanges(events) {\n      return _snapshotChanges(query, events, outsideAngularScheduler).pipe(keepUnstableUntilFirst);\n    },\n    stateChanges: function stateChanges(events) {\n      return _stateChanges(query, events, outsideAngularScheduler).pipe(keepUnstableUntilFirst);\n    },\n    auditTrail: function auditTrail(events) {\n      return _auditTrail(query, events, outsideAngularScheduler).pipe(keepUnstableUntilFirst);\n    },\n    valueChanges: function valueChanges(events, options) {\n      var snapshotChanges$ = _snapshotChanges(query, events, outsideAngularScheduler);\n\n      return snapshotChanges$.pipe(map(function (actions) {\n        return actions.map(function (a) {\n          if (options && options.idField) {\n            return Object.assign(Object.assign({}, a.payload.val()), _defineProperty({}, options.idField, a.key));\n          } else {\n            return a.payload.val();\n          }\n        });\n      }), keepUnstableUntilFirst);\n    }\n  };\n}\n\nfunction createObjectSnapshotChanges(query, scheduler) {\n  return function snapshotChanges() {\n    return fromRef(query, 'value', 'on', scheduler);\n  };\n}\n\nfunction createObjectReference(query, afDatabase) {\n  return {\n    query: query,\n    snapshotChanges: function snapshotChanges() {\n      return createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)().pipe(keepUnstableUntilFirst);\n    },\n    update: function update(data) {\n      return query.ref.update(data);\n    },\n    set: function set(data) {\n      return query.ref.set(data);\n    },\n    remove: function remove() {\n      return query.ref.remove();\n    },\n    valueChanges: function valueChanges() {\n      var snapshotChanges$ = createObjectSnapshotChanges(query, afDatabase.schedulers.outsideAngular)();\n      return snapshotChanges$.pipe(keepUnstableUntilFirst, map(function (action) {\n        return action.payload.exists() ? action.payload.val() : null;\n      }));\n    }\n  };\n}\n\nvar URL = /*#__PURE__*/new InjectionToken('angularfire2.realtimeDatabaseURL');\nvar USE_EMULATOR = /*#__PURE__*/new InjectionToken('angularfire2.database.use-emulator');\nvar AngularFireDatabase = /*#__PURE__*/(function () {\n  var AngularFireDatabase = /*#__PURE__*/function () {\n    function AngularFireDatabase(options, name, databaseURL, // tslint:disable-next-line:ban-types\n    platformId, zone, schedulers, _useEmulator, // tuple isn't working here\n    auth, useAuthEmulator, authSettings, // can't use firebase.auth.AuthSettings here\n    tenantId, languageCode, useDeviceLanguage, persistence, _appCheckInstances) {\n      _classCallCheck(this, AngularFireDatabase);\n\n      this.schedulers = schedulers;\n      var useEmulator = _useEmulator;\n      var app = ɵfirebaseAppFactory(options, zone, name);\n\n      if (auth) {\n        ɵauthFactory(app, zone, useAuthEmulator, tenantId, languageCode, useDeviceLanguage, authSettings, persistence);\n      }\n\n      this.database = ɵcacheInstance(\"\".concat(app.name, \".database.\").concat(databaseURL), 'AngularFireDatabase', app.name, function () {\n        var database = zone.runOutsideAngular(function () {\n          return app.database(databaseURL || undefined);\n        });\n\n        if (useEmulator) {\n          database.useEmulator.apply(database, _toConsumableArray(useEmulator));\n        }\n\n        return database;\n      }, [useEmulator]);\n    }\n\n    _createClass(AngularFireDatabase, [{\n      key: \"list\",\n      value: function list(pathOrRef, queryFn) {\n        var _this = this;\n\n        var ref = this.schedulers.ngZone.runOutsideAngular(function () {\n          return getRef(_this.database, pathOrRef);\n        });\n        var query = ref;\n\n        if (queryFn) {\n          query = queryFn(ref);\n        }\n\n        return createListReference(query, this);\n      }\n    }, {\n      key: \"object\",\n      value: function object(pathOrRef) {\n        var _this2 = this;\n\n        var ref = this.schedulers.ngZone.runOutsideAngular(function () {\n          return getRef(_this2.database, pathOrRef);\n        });\n        return createObjectReference(ref, this);\n      }\n    }, {\n      key: \"createPushId\",\n      value: function createPushId() {\n        var _this3 = this;\n\n        var ref = this.schedulers.ngZone.runOutsideAngular(function () {\n          return _this3.database.ref();\n        });\n        return ref.push().key;\n      }\n    }]);\n\n    return AngularFireDatabase;\n  }();\n\n  AngularFireDatabase.ɵfac = function AngularFireDatabase_Factory(t) {\n    return new (t || AngularFireDatabase)(i0.ɵɵinject(FIREBASE_OPTIONS), i0.ɵɵinject(FIREBASE_APP_NAME, 8), i0.ɵɵinject(URL, 8), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i1.ɵAngularFireSchedulers), i0.ɵɵinject(USE_EMULATOR, 8), i0.ɵɵinject(i2.AngularFireAuth, 8), i0.ɵɵinject(USE_EMULATOR$1, 8), i0.ɵɵinject(SETTINGS, 8), i0.ɵɵinject(TENANT_ID, 8), i0.ɵɵinject(LANGUAGE_CODE, 8), i0.ɵɵinject(USE_DEVICE_LANGUAGE, 8), i0.ɵɵinject(PERSISTENCE, 8), i0.ɵɵinject(i3.AppCheckInstances, 8));\n  };\n\n  AngularFireDatabase.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: AngularFireDatabase,\n    factory: AngularFireDatabase.ɵfac,\n    providedIn: 'any'\n  });\n  return AngularFireDatabase;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nvar AngularFireDatabaseModule = /*#__PURE__*/(function () {\n  var AngularFireDatabaseModule = /*#__PURE__*/_createClass(function AngularFireDatabaseModule() {\n    _classCallCheck(this, AngularFireDatabaseModule);\n\n    firebase.registerVersion('angularfire', VERSION.full, 'rtdb-compat');\n  });\n\n  AngularFireDatabaseModule.ɵfac = function AngularFireDatabaseModule_Factory(t) {\n    return new (t || AngularFireDatabaseModule)();\n  };\n\n  AngularFireDatabaseModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: AngularFireDatabaseModule\n  });\n  AngularFireDatabaseModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [AngularFireDatabase]\n  });\n  return AngularFireDatabaseModule;\n})();\n\n/*#__PURE__*/\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { AngularFireDatabase, AngularFireDatabaseModule, URL, USE_EMULATOR, _auditTrail as auditTrail, createListReference, fromRef, listChanges, _snapshotChanges as snapshotChanges, _stateChanges as stateChanges }; //# sourceMappingURL=angular-fire-compat-database.js.map","map":null,"metadata":{},"sourceType":"module"}